/**
 * Sub-agent tool creation utilities for hierarchical agent systems.
 *
 * This module provides helpers for wrapping agents as tools that can be invoked
 * by parent agents, enabling hierarchical delegation of tasks. Sub-agents execute
 * independently but propagate events back to the parent for observability.
 *
 * Per UAP-1.0 Section 8.7, implementations SHOULD provide helper utilities
 * for creating sub-agent tools with event propagation.
 *
 * @remarks
 * Sub-agents are useful for:
 * - Delegating specialized tasks (research, code exploration, summarization)
 * - Isolating tool access (give sub-agent specific tools without exposing to parent)
 * - Managing complexity in multi-step workflows
 * - Enabling parallel execution of independent tasks
 *
 * @example
 * ```typescript
 * import { agent } from '@providerprotocol/agents';
 * import { createSubAgentTool } from '@providerprotocol/agents/subagent';
 *
 * // Create a sub-agent
 * const explorer = agent({
 *   model: anthropic('claude-haiku-4-20250514'),
 *   tools: [Glob, Grep, Read],
 *   system: 'You explore codebases.',
 * });
 *
 * // Wrap as a tool with event propagation
 * const explorerTool = createSubAgentTool({
 *   agent: explorer,
 *   name: 'explore_codebase',
 *   description: 'Explore and find relevant code',
 *   parameters: {
 *     type: 'object',
 *     properties: {
 *       query: { type: 'string', description: 'What to find' },
 *     },
 *     required: ['query'],
 *   },
 *   buildPrompt: (params) => `Find: ${params.query}`,
 *   subagentType: 'explorer',
 * });
 *
 * // Use in parent agent
 * const coder = agent({
 *   model: anthropic('claude-sonnet-4-20250514'),
 *   tools: [Bash, Write, explorerTool],
 * });
 * ```
 *
 * @packageDocumentation
 */

import type { Tool, JSONSchema } from '@providerprotocol/ai';
import type { Agent } from '../agent/types.ts';
import type {
  ToolExecutionContext,
  SubagentEvent,
  SubagentStartEvent,
  SubagentEndEvent,
} from '../execution/types.ts';
import { AgentState } from '../state/index.ts';
import { generateUUID } from '../utils/uuid.ts';

/**
 * Configuration options for creating a sub-agent tool.
 *
 * Defines how an agent should be exposed as a callable tool, including
 * its name, parameters, and how to transform tool arguments into prompts.
 *
 * @see {@link createSubAgentTool} for usage examples
 */
export interface CreateSubAgentToolOptions {
  /**
   * The agent instance to expose as a tool.
   *
   * This agent will be invoked when the parent agent calls the tool.
   * The sub-agent executes independently with its own tools and system prompt.
   */
  agent: Agent;

  /**
   * Unique name for the tool.
   *
   * Must be unique within the parent agent's tool set. This name is used
   * by the parent agent's model to invoke the sub-agent.
   */
  name: string;

  /**
   * Description of what the tool does.
   *
   * This is provided to the parent agent's model to help it decide when
   * to use this tool. Be specific about the sub-agent's capabilities.
   */
  description: string;

  /**
   * JSON Schema defining the tool's input parameters.
   *
   * The parent agent's model will generate arguments matching this schema
   * when invoking the tool. These arguments are passed to `buildPrompt`.
   */
  parameters: JSONSchema;

  /**
   * Transforms tool parameters into a prompt string for the sub-agent.
   *
   * This function receives the arguments generated by the parent agent's model
   * and should return a natural language prompt for the sub-agent.
   *
   * @param params - The tool arguments matching the `parameters` schema
   * @returns A prompt string to send to the sub-agent
   */
  buildPrompt: (params: Record<string, unknown>) => string;

  /**
   * Identifier for the sub-agent type used in event payloads.
   *
   * Useful for distinguishing between different sub-agent types in logs
   * and event handlers. Defaults to the tool `name` if not specified.
   *
   * @defaultValue The tool `name`
   */
  subagentType?: string;

  /**
   * Whether to stream the sub-agent execution.
   *
   * When `true`, inner events from the sub-agent (text deltas, tool calls, etc.)
   * are forwarded to the parent through `subagent_event` events, enabling
   * real-time visibility into sub-agent progress.
   *
   * When `false`, only `subagent_start` and `subagent_end` events are emitted.
   *
   * @defaultValue true
   */
  stream?: boolean;
}

/**
 * Creates a UPP Tool from a UAP Agent with full event propagation.
 *
 * This function wraps an agent as a tool that can be invoked by a parent agent,
 * enabling hierarchical agent architectures. The resulting tool handles all
 * event propagation automatically.
 *
 * Per UAP-1.0 Section 8.7, this helper:
 * 1. Emits `subagent_start` before execution begins
 * 2. Forwards inner events during streaming execution (when `stream: true`)
 * 3. Emits `subagent_end` after completion (success or failure)
 * 4. Provides execution context to sub-agent for tracing
 *
 * The created tool accepts an optional `ToolExecutionContext` as a second
 * parameter, which is injected by `injectToolContext()` during execution.
 *
 * @param options - Configuration for the sub-agent tool
 * @returns A Tool definition that executes the sub-agent when called
 *
 * @throws Re-throws any error from the sub-agent after emitting a `subagent_end` event with `success: false`
 *
 * @example Basic usage
 * ```typescript
 * const summarizer = agent({
 *   model: anthropic('claude-haiku-4-20250514'),
 *   system: 'You summarize text concisely.',
 * });
 *
 * const summarizerTool = createSubAgentTool({
 *   agent: summarizer,
 *   name: 'summarize',
 *   description: 'Summarize the given text',
 *   parameters: {
 *     type: 'object',
 *     properties: {
 *       text: { type: 'string', description: 'Text to summarize' },
 *       maxLength: { type: 'number', description: 'Max summary length' },
 *     },
 *     required: ['text'],
 *   },
 *   buildPrompt: (params) =>
 *     `Summarize this in ${params.maxLength ?? 100} words:\n\n${params.text}`,
 *   subagentType: 'summarizer',
 * });
 *
 * // Use in a parent agent
 * const parentAgent = agent({
 *   model: anthropic('claude-sonnet-4-20250514'),
 *   tools: [summarizerTool],
 * });
 * ```
 *
 * @example Non-streaming mode
 * ```typescript
 * const tool = createSubAgentTool({
 *   agent: myAgent,
 *   name: 'helper',
 *   description: 'A helper agent',
 *   parameters: { type: 'object', properties: {} },
 *   buildPrompt: (params) => params.task as string,
 *   stream: false, // Only emit start/end events, no inner events
 * });
 * ```
 *
 * @see {@link CreateSubAgentToolOptions} for configuration details
 */
export function createSubAgentTool(options: CreateSubAgentToolOptions): Tool {
  const {
    agent,
    name,
    description,
    parameters,
    buildPrompt,
    subagentType = name,
    stream: shouldStream = true,
  } = options;

  return {
    name,
    description,
    parameters,
    run: async (
      params: Record<string, unknown>,
      context?: ToolExecutionContext,
    ): Promise<string> => {
      // Generate unique identifiers for tracing this sub-agent invocation
      const subagentId = generateUUID();
      const toolCallId = context?.toolCallId ?? generateUUID();
      const emit = context?.onSubagentEvent;
      const prompt = buildPrompt(params);
      const startTime = Date.now();

      // Emit subagent_start event to notify parent that execution is beginning
      const startEvent: SubagentStartEvent = {
        type: 'subagent_start',
        subagentId,
        subagentType,
        parentToolCallId: toolCallId,
        prompt,
        timestamp: startTime,
      };
      emit?.(startEvent);

      try {
        // Execute the sub-agent, optionally streaming inner events to parent
        if (shouldStream) {
          return await executeWithStreaming(
            agent,
            prompt,
            subagentId,
            subagentType,
            toolCallId,
            emit,
          );
        }
        return await executeWithoutStreaming(
          agent,
          prompt,
          subagentId,
          subagentType,
          toolCallId,
          emit,
        );
      } catch (error) {
        // Normalize error and emit subagent_end with failure status
        const err = error instanceof Error ? error : new Error(String(error));

        const endEvent: SubagentEndEvent = {
          type: 'subagent_end',
          subagentId,
          subagentType,
          parentToolCallId: toolCallId,
          success: false,
          error: err.message,
          timestamp: Date.now(),
        };
        emit?.(endEvent);

        // Re-throw to allow parent to handle the error
        throw err;
      }
    },
  };
}

/**
 * Executes a sub-agent with streaming enabled, forwarding all inner events.
 *
 * This function streams the sub-agent execution and wraps each event from
 * the sub-agent in a `subagent_event` envelope before forwarding it to the
 * parent's event handler. This provides real-time visibility into sub-agent
 * progress, including text generation, tool calls, and other events.
 *
 * After the stream completes, emits a `subagent_end` event with the final
 * result and usage statistics.
 *
 * @param agent - The sub-agent to execute
 * @param prompt - The prompt to send to the sub-agent
 * @param subagentId - Unique identifier for this sub-agent invocation
 * @param subagentType - Type identifier for the sub-agent (for event categorization)
 * @param toolCallId - The parent tool call ID that triggered this invocation
 * @param emit - Optional callback to emit sub-agent events to the parent
 * @returns The final text response from the sub-agent
 */
async function executeWithStreaming(
  agent: Agent,
  prompt: string,
  subagentId: string,
  subagentType: string,
  toolCallId: string,
  emit?: (event: SubagentEvent) => void,
): Promise<string> {
  const stream = agent.stream(prompt, AgentState.initial());

  for await (const event of stream) {
    emit?.({
      type: 'subagent_event',
      subagentId,
      subagentType,
      parentToolCallId: toolCallId,
      innerEvent: event,
    });
  }

  const result = await stream.result;

  const endEvent: SubagentEndEvent = {
    type: 'subagent_end',
    subagentId,
    subagentType,
    parentToolCallId: toolCallId,
    success: true,
    result: result.turn.response.text,
    timestamp: Date.now(),
    toolExecutions: result.turn.toolExecutions?.map((te) => ({
      toolName: te.toolName,
      arguments: te.arguments as Record<string, unknown>,
      result: String(te.result),
    })),
    usage: result.turn.usage,
  };
  emit?.(endEvent);

  return result.turn.response.text;
}

/**
 * Executes a sub-agent without streaming, using the synchronous generate API.
 *
 * This function runs the sub-agent to completion without forwarding inner
 * events. Only the final `subagent_end` event is emitted after execution
 * completes. This is simpler and has less overhead than streaming, but
 * provides no visibility into sub-agent progress during execution.
 *
 * Useful when the parent does not need real-time updates from sub-agents,
 * or when minimizing event overhead is important.
 *
 * @param agent - The sub-agent to execute
 * @param prompt - The prompt to send to the sub-agent
 * @param subagentId - Unique identifier for this sub-agent invocation
 * @param subagentType - Type identifier for the sub-agent (for event categorization)
 * @param toolCallId - The parent tool call ID that triggered this invocation
 * @param emit - Optional callback to emit the final sub-agent end event
 * @returns The final text response from the sub-agent
 */
async function executeWithoutStreaming(
  agent: Agent,
  prompt: string,
  subagentId: string,
  subagentType: string,
  toolCallId: string,
  emit?: (event: SubagentEvent) => void,
): Promise<string> {
  const result = await agent.generate(prompt, AgentState.initial());

  const endEvent: SubagentEndEvent = {
    type: 'subagent_end',
    subagentId,
    subagentType,
    parentToolCallId: toolCallId,
    success: true,
    result: result.turn.response.text,
    timestamp: Date.now(),
    toolExecutions: result.turn.toolExecutions?.map((te) => ({
      toolName: te.toolName,
      arguments: te.arguments as Record<string, unknown>,
      result: String(te.result),
    })),
    usage: result.turn.usage,
  };
  emit?.(endEvent);

  return result.turn.response.text;
}

/**
 * Function signature for a sub-agent tool's run method.
 *
 * This type represents the shape of the `run` function created by
 * {@link createSubAgentTool}. It accepts the tool parameters and an optional
 * execution context that provides event propagation capabilities.
 *
 * @param params - The tool parameters as defined by the tool's JSON Schema
 * @param context - Optional execution context for event propagation and tracing
 * @returns A promise resolving to the sub-agent's text response
 *
 * @example
 * ```typescript
 * // Type-safe tool invocation
 * const tool = createSubAgentTool({ ... });
 * const run = tool.run as SubAgentToolRun;
 *
 * const result = await run(
 *   { query: 'search term' },
 *   { toolCallId: 'call_123', onSubagentEvent: handleEvent }
 * );
 * ```
 */
export type SubAgentToolRun = (
  params: Record<string, unknown>,
  context?: ToolExecutionContext,
) => Promise<string>;
